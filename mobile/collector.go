// Package mobile contains the mobile API
package mobile

import (
	"context"
	"encoding/json"
	"fmt"
	"time"

	"github.com/measurement-kit/engine/model"
	"github.com/measurement-kit/engine/nettest"
)

// MKECollectorResubmitResults contains the results of resubmitting
// a measurement to the OONI collector.
type MKECollectorResubmitResults struct {
	good        bool
	measurement string
	logs        string
}

// Good returns true if the measurement was correctly submitted
// to the OONI collector, false otherwise.
func (x *MKECollectorResubmitResults) Good() bool {
	return x.good
}

// UpdatedSerializedMeasurement returns the updated measurement where the
// report ID has been modified to be the one returned by the collector.
func (x *MKECollectorResubmitResults) UpdatedSerializedMeasurement() string {
	return x.measurement
}

// Logs returns the logs generated by resubmitting the measurement.
func (x *MKECollectorResubmitResults) Logs() string {
	return x.logs
}

// MKECollectorResubmitSettings contains settings indicating how to
// resubmit a specific OONI measurement.
type MKECollectorResubmitSettings struct {
	measurement string
	timeout     int64
}

// SetSerializedMeasurement sets the measurement to be resubmitted.
func (x *MKECollectorResubmitSettings) SetSerializedMeasurement(s string) {
	x.measurement = s
}

// SetTimeout set the number of seconds after which resubmission is aborted.
func (x *MKECollectorResubmitSettings) SetTimeout(timeout int64) {
	x.timeout = timeout
}

// Perform resubmits a measurement and returns the results.
func (x *MKECollectorResubmitSettings) Perform() *MKECollectorResubmitResults {
	// Implementation note: here we basically run the normal nettest workflow
	// except that the measurement result is known ahead of time.
	var out MKECollectorResubmitResults
	var measurement model.Measurement
	err := json.Unmarshal([]byte(x.measurement), &measurement)
	if err != nil {
		out.logs = fmt.Sprintf("cannot unmarshal measurement: %s\n", err.Error())
		return &out
	}
	var nettest nettest.Nettest
	const maxTimeout = int64(120)
	if x.timeout < 0 || x.timeout > maxTimeout {
		out.logs = fmt.Sprintf("timeout is negative or too large\n")
		return &out
	}
	duration := time.Duration(x.timeout) * time.Second
	ctx, cancel := context.WithTimeout(context.Background(), duration)
	defer cancel()
	nettest.Ctx = ctx
	nettest.TestName = measurement.TestName
	nettest.TestVersion = measurement.TestVersion
	nettest.SoftwareName = measurement.SoftwareName
	nettest.SoftwareVersion = measurement.SoftwareVersion
	nettest.TestStartTime = measurement.TestStartTime
	err = nettest.DiscoverAvailableCollectors()
	if err != nil {
		out.logs = fmt.Sprintf("cannot discover collectors: %s\n", err.Error())
		return &out
	}
	err = nettest.OpenReport()
	if err != nil {
		out.logs = fmt.Sprintf("cannot open report: %s\n", err.Error())
		return &out
	}
	defer nettest.CloseReport()
	err = nettest.SubmitMeasurement(&measurement)
	if err != nil {
		out.logs = fmt.Sprintf("cannot submit measurement: %s\n", err.Error())
		return &out
	}
	data, err := json.Marshal(measurement)
	if err != nil {
		out.logs = fmt.Sprintf("cannot marshal measurement: %s\n", err.Error())
		return &out
	}
	out.measurement = string(data)
	out.good = true
	return &out
}
